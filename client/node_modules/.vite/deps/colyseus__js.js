import {
  require_umd
} from "./chunk-T27CQSQS.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-DZZM6G22.js";

// ../node_modules/colyseus.js/lib/legacy.js
var require_legacy = __commonJS({
  "../node_modules/colyseus.js/lib/legacy.js"() {
    if (!ArrayBuffer.isView) {
      ArrayBuffer.isView = (a) => {
        return a !== null && typeof a === "object" && a.buffer instanceof ArrayBuffer;
      };
    }
    if (typeof globalThis === "undefined" && typeof window !== "undefined") {
      window["globalThis"] = window;
    }
  }
});

// ../node_modules/colyseus.js/lib/errors/ServerError.js
var require_ServerError = __commonJS({
  "../node_modules/colyseus.js/lib/errors/ServerError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerError = exports.CloseCode = void 0;
    var CloseCode;
    (function(CloseCode2) {
      CloseCode2[CloseCode2["CONSENTED"] = 4e3] = "CONSENTED";
      CloseCode2[CloseCode2["DEVMODE_RESTART"] = 4010] = "DEVMODE_RESTART";
    })(CloseCode = exports.CloseCode || (exports.CloseCode = {}));
    var ServerError = class extends Error {
      constructor(code, message) {
        super(message);
        this.name = "ServerError";
        this.code = code;
      }
    };
    exports.ServerError = ServerError;
  }
});

// ../node_modules/colyseus.js/lib/msgpack/index.js
var require_msgpack = __commonJS({
  "../node_modules/colyseus.js/lib/msgpack/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = void 0;
    function Decoder(buffer, offset) {
      this._offset = offset;
      if (buffer instanceof ArrayBuffer) {
        this._buffer = buffer;
        this._view = new DataView(this._buffer);
      } else if (ArrayBuffer.isView(buffer)) {
        this._buffer = buffer.buffer;
        this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);
      } else {
        throw new Error("Invalid argument");
      }
    }
    function utf8Read(view, offset, length) {
      var string = "", chr = 0;
      for (var i = offset, end = offset + length; i < end; i++) {
        var byte = view.getUint8(i);
        if ((byte & 128) === 0) {
          string += String.fromCharCode(byte);
          continue;
        }
        if ((byte & 224) === 192) {
          string += String.fromCharCode((byte & 31) << 6 | view.getUint8(++i) & 63);
          continue;
        }
        if ((byte & 240) === 224) {
          string += String.fromCharCode((byte & 15) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0);
          continue;
        }
        if ((byte & 248) === 240) {
          chr = (byte & 7) << 18 | (view.getUint8(++i) & 63) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0;
          if (chr >= 65536) {
            chr -= 65536;
            string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
          } else {
            string += String.fromCharCode(chr);
          }
          continue;
        }
        throw new Error("Invalid byte " + byte.toString(16));
      }
      return string;
    }
    Decoder.prototype._array = function(length) {
      var value = new Array(length);
      for (var i = 0; i < length; i++) {
        value[i] = this._parse();
      }
      return value;
    };
    Decoder.prototype._map = function(length) {
      var key = "", value = {};
      for (var i = 0; i < length; i++) {
        key = this._parse();
        value[key] = this._parse();
      }
      return value;
    };
    Decoder.prototype._str = function(length) {
      var value = utf8Read(this._view, this._offset, length);
      this._offset += length;
      return value;
    };
    Decoder.prototype._bin = function(length) {
      var value = this._buffer.slice(this._offset, this._offset + length);
      this._offset += length;
      return value;
    };
    Decoder.prototype._parse = function() {
      var prefix = this._view.getUint8(this._offset++);
      var value, length = 0, type = 0, hi = 0, lo = 0;
      if (prefix < 192) {
        if (prefix < 128) {
          return prefix;
        }
        if (prefix < 144) {
          return this._map(prefix & 15);
        }
        if (prefix < 160) {
          return this._array(prefix & 15);
        }
        return this._str(prefix & 31);
      }
      if (prefix > 223) {
        return (255 - prefix + 1) * -1;
      }
      switch (prefix) {
        // nil
        case 192:
          return null;
        // false
        case 194:
          return false;
        // true
        case 195:
          return true;
        // bin
        case 196:
          length = this._view.getUint8(this._offset);
          this._offset += 1;
          return this._bin(length);
        case 197:
          length = this._view.getUint16(this._offset);
          this._offset += 2;
          return this._bin(length);
        case 198:
          length = this._view.getUint32(this._offset);
          this._offset += 4;
          return this._bin(length);
        // ext
        case 199:
          length = this._view.getUint8(this._offset);
          type = this._view.getInt8(this._offset + 1);
          this._offset += 2;
          if (type === -1) {
            var ns = this._view.getUint32(this._offset);
            hi = this._view.getInt32(this._offset + 4);
            lo = this._view.getUint32(this._offset + 8);
            this._offset += 12;
            return new Date((hi * 4294967296 + lo) * 1e3 + ns / 1e6);
          }
          return [type, this._bin(length)];
        case 200:
          length = this._view.getUint16(this._offset);
          type = this._view.getInt8(this._offset + 2);
          this._offset += 3;
          return [type, this._bin(length)];
        case 201:
          length = this._view.getUint32(this._offset);
          type = this._view.getInt8(this._offset + 4);
          this._offset += 5;
          return [type, this._bin(length)];
        // float
        case 202:
          value = this._view.getFloat32(this._offset);
          this._offset += 4;
          return value;
        case 203:
          value = this._view.getFloat64(this._offset);
          this._offset += 8;
          return value;
        // uint
        case 204:
          value = this._view.getUint8(this._offset);
          this._offset += 1;
          return value;
        case 205:
          value = this._view.getUint16(this._offset);
          this._offset += 2;
          return value;
        case 206:
          value = this._view.getUint32(this._offset);
          this._offset += 4;
          return value;
        case 207:
          hi = this._view.getUint32(this._offset) * Math.pow(2, 32);
          lo = this._view.getUint32(this._offset + 4);
          this._offset += 8;
          return hi + lo;
        // int
        case 208:
          value = this._view.getInt8(this._offset);
          this._offset += 1;
          return value;
        case 209:
          value = this._view.getInt16(this._offset);
          this._offset += 2;
          return value;
        case 210:
          value = this._view.getInt32(this._offset);
          this._offset += 4;
          return value;
        case 211:
          hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
          lo = this._view.getUint32(this._offset + 4);
          this._offset += 8;
          return hi + lo;
        // fixext
        case 212:
          type = this._view.getInt8(this._offset);
          this._offset += 1;
          if (type === 0) {
            this._offset += 1;
            return void 0;
          }
          return [type, this._bin(1)];
        case 213:
          type = this._view.getInt8(this._offset);
          this._offset += 1;
          return [type, this._bin(2)];
        case 214:
          type = this._view.getInt8(this._offset);
          this._offset += 1;
          if (type === -1) {
            value = this._view.getUint32(this._offset);
            this._offset += 4;
            return new Date(value * 1e3);
          }
          return [type, this._bin(4)];
        case 215:
          type = this._view.getInt8(this._offset);
          this._offset += 1;
          if (type === 0) {
            hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
            lo = this._view.getUint32(this._offset + 4);
            this._offset += 8;
            return new Date(hi + lo);
          }
          if (type === -1) {
            hi = this._view.getUint32(this._offset);
            lo = this._view.getUint32(this._offset + 4);
            this._offset += 8;
            var s = (hi & 3) * 4294967296 + lo;
            return new Date(s * 1e3 + (hi >>> 2) / 1e6);
          }
          return [type, this._bin(8)];
        case 216:
          type = this._view.getInt8(this._offset);
          this._offset += 1;
          return [type, this._bin(16)];
        // str
        case 217:
          length = this._view.getUint8(this._offset);
          this._offset += 1;
          return this._str(length);
        case 218:
          length = this._view.getUint16(this._offset);
          this._offset += 2;
          return this._str(length);
        case 219:
          length = this._view.getUint32(this._offset);
          this._offset += 4;
          return this._str(length);
        // array
        case 220:
          length = this._view.getUint16(this._offset);
          this._offset += 2;
          return this._array(length);
        case 221:
          length = this._view.getUint32(this._offset);
          this._offset += 4;
          return this._array(length);
        // map
        case 222:
          length = this._view.getUint16(this._offset);
          this._offset += 2;
          return this._map(length);
        case 223:
          length = this._view.getUint32(this._offset);
          this._offset += 4;
          return this._map(length);
      }
      throw new Error("Could not parse");
    };
    function decode(buffer, offset = 0) {
      var decoder = new Decoder(buffer, offset);
      var value = decoder._parse();
      if (decoder._offset !== buffer.byteLength) {
        throw new Error(buffer.byteLength - decoder._offset + " trailing bytes");
      }
      return value;
    }
    exports.decode = decode;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function utf8Write(view, offset, str) {
      var c = 0;
      for (var i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 128) {
          view.setUint8(offset++, c);
        } else if (c < 2048) {
          view.setUint8(offset++, 192 | c >> 6);
          view.setUint8(offset++, 128 | c & 63);
        } else if (c < 55296 || c >= 57344) {
          view.setUint8(offset++, 224 | c >> 12);
          view.setUint8(offset++, 128 | c >> 6 & 63);
          view.setUint8(offset++, 128 | c & 63);
        } else {
          i++;
          c = 65536 + ((c & 1023) << 10 | str.charCodeAt(i) & 1023);
          view.setUint8(offset++, 240 | c >> 18);
          view.setUint8(offset++, 128 | c >> 12 & 63);
          view.setUint8(offset++, 128 | c >> 6 & 63);
          view.setUint8(offset++, 128 | c & 63);
        }
      }
    }
    function utf8Length(str) {
      var c = 0, length = 0;
      for (var i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 128) {
          length += 1;
        } else if (c < 2048) {
          length += 2;
        } else if (c < 55296 || c >= 57344) {
          length += 3;
        } else {
          i++;
          length += 4;
        }
      }
      return length;
    }
    function _encode(bytes, defers, value) {
      var type = typeof value, i = 0, l = 0, hi = 0, lo = 0, length = 0, size = 0;
      if (type === "string") {
        length = utf8Length(value);
        if (length < 32) {
          bytes.push(length | 160);
          size = 1;
        } else if (length < 256) {
          bytes.push(217, length);
          size = 2;
        } else if (length < 65536) {
          bytes.push(218, length >> 8, length);
          size = 3;
        } else if (length < 4294967296) {
          bytes.push(219, length >> 24, length >> 16, length >> 8, length);
          size = 5;
        } else {
          throw new Error("String too long");
        }
        defers.push({ _str: value, _length: length, _offset: bytes.length });
        return size + length;
      }
      if (type === "number") {
        if (Math.floor(value) !== value || !isFinite(value)) {
          bytes.push(203);
          defers.push({ _float: value, _length: 8, _offset: bytes.length });
          return 9;
        }
        if (value >= 0) {
          if (value < 128) {
            bytes.push(value);
            return 1;
          }
          if (value < 256) {
            bytes.push(204, value);
            return 2;
          }
          if (value < 65536) {
            bytes.push(205, value >> 8, value);
            return 3;
          }
          if (value < 4294967296) {
            bytes.push(206, value >> 24, value >> 16, value >> 8, value);
            return 5;
          }
          hi = value / Math.pow(2, 32) >> 0;
          lo = value >>> 0;
          bytes.push(207, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
          return 9;
        } else {
          if (value >= -32) {
            bytes.push(value);
            return 1;
          }
          if (value >= -128) {
            bytes.push(208, value);
            return 2;
          }
          if (value >= -32768) {
            bytes.push(209, value >> 8, value);
            return 3;
          }
          if (value >= -2147483648) {
            bytes.push(210, value >> 24, value >> 16, value >> 8, value);
            return 5;
          }
          hi = Math.floor(value / Math.pow(2, 32));
          lo = value >>> 0;
          bytes.push(211, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
          return 9;
        }
      }
      if (type === "object") {
        if (value === null) {
          bytes.push(192);
          return 1;
        }
        if (Array.isArray(value)) {
          length = value.length;
          if (length < 16) {
            bytes.push(length | 144);
            size = 1;
          } else if (length < 65536) {
            bytes.push(220, length >> 8, length);
            size = 3;
          } else if (length < 4294967296) {
            bytes.push(221, length >> 24, length >> 16, length >> 8, length);
            size = 5;
          } else {
            throw new Error("Array too large");
          }
          for (i = 0; i < length; i++) {
            size += _encode(bytes, defers, value[i]);
          }
          return size;
        }
        if (value instanceof Date) {
          var ms = value.getTime();
          var s = Math.floor(ms / 1e3);
          var ns = (ms - s * 1e3) * 1e6;
          if (s >= 0 && ns >= 0 && s <= TIMESTAMP64_MAX_SEC) {
            if (ns === 0 && s <= TIMESTAMP32_MAX_SEC) {
              bytes.push(214, 255, s >> 24, s >> 16, s >> 8, s);
              return 6;
            } else {
              hi = s / 4294967296;
              lo = s & 4294967295;
              bytes.push(215, 255, ns >> 22, ns >> 14, ns >> 6, hi, lo >> 24, lo >> 16, lo >> 8, lo);
              return 10;
            }
          } else {
            hi = Math.floor(s / 4294967296);
            lo = s >>> 0;
            bytes.push(199, 12, 255, ns >> 24, ns >> 16, ns >> 8, ns, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
            return 15;
          }
        }
        if (value instanceof ArrayBuffer) {
          length = value.byteLength;
          if (length < 256) {
            bytes.push(196, length);
            size = 2;
          } else if (length < 65536) {
            bytes.push(197, length >> 8, length);
            size = 3;
          } else if (length < 4294967296) {
            bytes.push(198, length >> 24, length >> 16, length >> 8, length);
            size = 5;
          } else {
            throw new Error("Buffer too large");
          }
          defers.push({ _bin: value, _length: length, _offset: bytes.length });
          return size + length;
        }
        if (typeof value.toJSON === "function") {
          return _encode(bytes, defers, value.toJSON());
        }
        var keys = [], key = "";
        var allKeys = Object.keys(value);
        for (i = 0, l = allKeys.length; i < l; i++) {
          key = allKeys[i];
          if (value[key] !== void 0 && typeof value[key] !== "function") {
            keys.push(key);
          }
        }
        length = keys.length;
        if (length < 16) {
          bytes.push(length | 128);
          size = 1;
        } else if (length < 65536) {
          bytes.push(222, length >> 8, length);
          size = 3;
        } else if (length < 4294967296) {
          bytes.push(223, length >> 24, length >> 16, length >> 8, length);
          size = 5;
        } else {
          throw new Error("Object too large");
        }
        for (i = 0; i < length; i++) {
          key = keys[i];
          size += _encode(bytes, defers, key);
          size += _encode(bytes, defers, value[key]);
        }
        return size;
      }
      if (type === "boolean") {
        bytes.push(value ? 195 : 194);
        return 1;
      }
      if (type === "undefined") {
        bytes.push(192);
        return 1;
      }
      if (typeof value.toJSON === "function") {
        return _encode(bytes, defers, value.toJSON());
      }
      throw new Error("Could not encode");
    }
    function encode(value) {
      var bytes = [];
      var defers = [];
      var size = _encode(bytes, defers, value);
      var buf = new ArrayBuffer(size);
      var view = new DataView(buf);
      var deferIndex = 0;
      var deferWritten = 0;
      var nextOffset = -1;
      if (defers.length > 0) {
        nextOffset = defers[0]._offset;
      }
      var defer, deferLength = 0, offset = 0;
      for (var i = 0, l = bytes.length; i < l; i++) {
        view.setUint8(deferWritten + i, bytes[i]);
        if (i + 1 !== nextOffset) {
          continue;
        }
        defer = defers[deferIndex];
        deferLength = defer._length;
        offset = deferWritten + nextOffset;
        if (defer._bin) {
          var bin = new Uint8Array(defer._bin);
          for (var j = 0; j < deferLength; j++) {
            view.setUint8(offset + j, bin[j]);
          }
        } else if (defer._str) {
          utf8Write(view, offset, defer._str);
        } else if (defer._float !== void 0) {
          view.setFloat64(offset, defer._float);
        }
        deferIndex++;
        deferWritten += deferLength;
        if (defers[deferIndex]) {
          nextOffset = defers[deferIndex]._offset;
        }
      }
      return buf;
    }
    exports.encode = encode;
  }
});

// ../node_modules/colyseus.js/node_modules/ws/browser.js
var require_browser = __commonJS({
  "../node_modules/colyseus.js/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// ../node_modules/colyseus.js/lib/transport/WebSocketTransport.js
var require_WebSocketTransport = __commonJS({
  "../node_modules/colyseus.js/lib/transport/WebSocketTransport.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketTransport = void 0;
    var ws_1 = __importDefault(require_browser());
    var WebSocket = globalThis.WebSocket || ws_1.default;
    var WebSocketTransport = class {
      constructor(events) {
        this.events = events;
      }
      send(data) {
        if (data instanceof ArrayBuffer) {
          this.ws.send(data);
        } else if (Array.isArray(data)) {
          this.ws.send(new Uint8Array(data).buffer);
        }
      }
      /**
       * @param url URL to connect to
       * @param headers custom headers to send with the connection (only supported in Node.js. Web Browsers do not allow setting custom headers)
       */
      connect(url, headers) {
        try {
          this.ws = new WebSocket(url, { headers, protocols: this.protocols });
        } catch (e) {
          this.ws = new WebSocket(url, this.protocols);
        }
        this.ws.binaryType = "arraybuffer";
        this.ws.onopen = this.events.onopen;
        this.ws.onmessage = this.events.onmessage;
        this.ws.onclose = this.events.onclose;
        this.ws.onerror = this.events.onerror;
      }
      close(code, reason) {
        this.ws.close(code, reason);
      }
      get isOpen() {
        return this.ws.readyState === WebSocket.OPEN;
      }
    };
    exports.WebSocketTransport = WebSocketTransport;
  }
});

// ../node_modules/colyseus.js/lib/Connection.js
var require_Connection = __commonJS({
  "../node_modules/colyseus.js/lib/Connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = void 0;
    var WebSocketTransport_1 = require_WebSocketTransport();
    var Connection = class {
      constructor() {
        this.events = {};
        this.transport = new WebSocketTransport_1.WebSocketTransport(this.events);
      }
      send(data) {
        this.transport.send(data);
      }
      connect(url, options) {
        this.transport.connect(url, options);
      }
      close(code, reason) {
        this.transport.close(code, reason);
      }
      get isOpen() {
        return this.transport.isOpen;
      }
    };
    exports.Connection = Connection;
  }
});

// ../node_modules/colyseus.js/lib/Protocol.js
var require_Protocol = __commonJS({
  "../node_modules/colyseus.js/lib/Protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8Length = exports.utf8Read = exports.ErrorCode = exports.Protocol = void 0;
    var Protocol;
    (function(Protocol2) {
      Protocol2[Protocol2["HANDSHAKE"] = 9] = "HANDSHAKE";
      Protocol2[Protocol2["JOIN_ROOM"] = 10] = "JOIN_ROOM";
      Protocol2[Protocol2["ERROR"] = 11] = "ERROR";
      Protocol2[Protocol2["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
      Protocol2[Protocol2["ROOM_DATA"] = 13] = "ROOM_DATA";
      Protocol2[Protocol2["ROOM_STATE"] = 14] = "ROOM_STATE";
      Protocol2[Protocol2["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
      Protocol2[Protocol2["ROOM_DATA_SCHEMA"] = 16] = "ROOM_DATA_SCHEMA";
      Protocol2[Protocol2["ROOM_DATA_BYTES"] = 17] = "ROOM_DATA_BYTES";
    })(Protocol = exports.Protocol || (exports.Protocol = {}));
    var ErrorCode;
    (function(ErrorCode2) {
      ErrorCode2[ErrorCode2["MATCHMAKE_NO_HANDLER"] = 4210] = "MATCHMAKE_NO_HANDLER";
      ErrorCode2[ErrorCode2["MATCHMAKE_INVALID_CRITERIA"] = 4211] = "MATCHMAKE_INVALID_CRITERIA";
      ErrorCode2[ErrorCode2["MATCHMAKE_INVALID_ROOM_ID"] = 4212] = "MATCHMAKE_INVALID_ROOM_ID";
      ErrorCode2[ErrorCode2["MATCHMAKE_UNHANDLED"] = 4213] = "MATCHMAKE_UNHANDLED";
      ErrorCode2[ErrorCode2["MATCHMAKE_EXPIRED"] = 4214] = "MATCHMAKE_EXPIRED";
      ErrorCode2[ErrorCode2["AUTH_FAILED"] = 4215] = "AUTH_FAILED";
      ErrorCode2[ErrorCode2["APPLICATION_ERROR"] = 4216] = "APPLICATION_ERROR";
    })(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
    function utf8Read(view, offset) {
      const length = view[offset++];
      var string = "", chr = 0;
      for (var i = offset, end = offset + length; i < end; i++) {
        var byte = view[i];
        if ((byte & 128) === 0) {
          string += String.fromCharCode(byte);
          continue;
        }
        if ((byte & 224) === 192) {
          string += String.fromCharCode((byte & 31) << 6 | view[++i] & 63);
          continue;
        }
        if ((byte & 240) === 224) {
          string += String.fromCharCode((byte & 15) << 12 | (view[++i] & 63) << 6 | (view[++i] & 63) << 0);
          continue;
        }
        if ((byte & 248) === 240) {
          chr = (byte & 7) << 18 | (view[++i] & 63) << 12 | (view[++i] & 63) << 6 | (view[++i] & 63) << 0;
          if (chr >= 65536) {
            chr -= 65536;
            string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
          } else {
            string += String.fromCharCode(chr);
          }
          continue;
        }
        throw new Error("Invalid byte " + byte.toString(16));
      }
      return string;
    }
    exports.utf8Read = utf8Read;
    function utf8Length(str = "") {
      let c = 0;
      let length = 0;
      for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 128) {
          length += 1;
        } else if (c < 2048) {
          length += 2;
        } else if (c < 55296 || c >= 57344) {
          length += 3;
        } else {
          i++;
          length += 4;
        }
      }
      return length + 1;
    }
    exports.utf8Length = utf8Length;
  }
});

// ../node_modules/colyseus.js/lib/serializer/Serializer.js
var require_Serializer = __commonJS({
  "../node_modules/colyseus.js/lib/serializer/Serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSerializer = exports.registerSerializer = void 0;
    var serializers = {};
    function registerSerializer(id, serializer) {
      serializers[id] = serializer;
    }
    exports.registerSerializer = registerSerializer;
    function getSerializer(id) {
      const serializer = serializers[id];
      if (!serializer) {
        throw new Error("missing serializer: " + id);
      }
      return serializer;
    }
    exports.getSerializer = getSerializer;
  }
});

// ../node_modules/colyseus.js/lib/core/nanoevents.js
var require_nanoevents = __commonJS({
  "../node_modules/colyseus.js/lib/core/nanoevents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNanoEvents = void 0;
    var createNanoEvents = () => ({
      emit(event, ...args) {
        let callbacks = this.events[event] || [];
        for (let i = 0, length = callbacks.length; i < length; i++) {
          callbacks[i](...args);
        }
      },
      events: {},
      on(event, cb) {
        var _a;
        ((_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.push(cb)) || (this.events[event] = [cb]);
        return () => {
          var _a2;
          this.events[event] = (_a2 = this.events[event]) === null || _a2 === void 0 ? void 0 : _a2.filter((i) => cb !== i);
        };
      }
    });
    exports.createNanoEvents = createNanoEvents;
  }
});

// ../node_modules/colyseus.js/lib/core/signal.js
var require_signal = __commonJS({
  "../node_modules/colyseus.js/lib/core/signal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSignal = exports.EventEmitter = void 0;
    var EventEmitter = class {
      constructor() {
        this.handlers = [];
      }
      register(cb, once = false) {
        this.handlers.push(cb);
        return this;
      }
      invoke(...args) {
        this.handlers.forEach((handler) => handler.apply(this, args));
      }
      invokeAsync(...args) {
        return Promise.all(this.handlers.map((handler) => handler.apply(this, args)));
      }
      remove(cb) {
        const index = this.handlers.indexOf(cb);
        this.handlers[index] = this.handlers[this.handlers.length - 1];
        this.handlers.pop();
      }
      clear() {
        this.handlers = [];
      }
    };
    exports.EventEmitter = EventEmitter;
    function createSignal() {
      const emitter = new EventEmitter();
      function register(cb) {
        return emitter.register(cb, this === null);
      }
      ;
      register.once = (cb) => {
        const callback = function(...args) {
          cb.apply(this, args);
          emitter.remove(callback);
        };
        emitter.register(callback);
      };
      register.remove = (cb) => emitter.remove(cb);
      register.invoke = (...args) => emitter.invoke(...args);
      register.invokeAsync = (...args) => emitter.invokeAsync(...args);
      register.clear = () => emitter.clear();
      return register;
    }
    exports.createSignal = createSignal;
  }
});

// ../node_modules/colyseus.js/lib/Room.js
var require_Room = __commonJS({
  "../node_modules/colyseus.js/lib/Room.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Room = void 0;
    var msgpack = __importStar(require_msgpack());
    var Connection_1 = require_Connection();
    var Protocol_1 = require_Protocol();
    var Serializer_1 = require_Serializer();
    var nanoevents_1 = require_nanoevents();
    var signal_1 = require_signal();
    var schema_1 = require_umd();
    var ServerError_1 = require_ServerError();
    var Room = class _Room {
      constructor(name, rootSchema) {
        this.onStateChange = (0, signal_1.createSignal)();
        this.onError = (0, signal_1.createSignal)();
        this.onLeave = (0, signal_1.createSignal)();
        this.onJoin = (0, signal_1.createSignal)();
        this.hasJoined = false;
        this.onMessageHandlers = (0, nanoevents_1.createNanoEvents)();
        this.roomId = null;
        this.name = name;
        if (rootSchema) {
          this.serializer = new ((0, Serializer_1.getSerializer)("schema"))();
          this.rootSchema = rootSchema;
          this.serializer.state = new rootSchema();
        }
        this.onError((code, message) => {
          var _a;
          return (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `colyseus.js - onError => (${code}) ${message}`);
        });
        this.onLeave(() => this.removeAllListeners());
      }
      // TODO: deprecate me on version 1.0
      get id() {
        return this.roomId;
      }
      connect(endpoint, devModeCloseCallback, room = this, headers) {
        const connection = new Connection_1.Connection();
        room.connection = connection;
        connection.events.onmessage = _Room.prototype.onMessageCallback.bind(room);
        connection.events.onclose = function(e) {
          var _a;
          if (!room.hasJoined) {
            (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `Room connection was closed unexpectedly (${e.code}): ${e.reason}`);
            room.onError.invoke(e.code, e.reason);
            return;
          }
          if (e.code === ServerError_1.CloseCode.DEVMODE_RESTART && devModeCloseCallback) {
            devModeCloseCallback();
          } else {
            room.onLeave.invoke(e.code, e.reason);
            room.destroy();
          }
        };
        connection.events.onerror = function(e) {
          var _a;
          (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `Room, onError (${e.code}): ${e.reason}`);
          room.onError.invoke(e.code, e.reason);
        };
        connection.connect(endpoint, headers);
      }
      leave(consented = true) {
        return new Promise((resolve) => {
          this.onLeave((code) => resolve(code));
          if (this.connection) {
            if (consented) {
              this.connection.send([Protocol_1.Protocol.LEAVE_ROOM]);
            } else {
              this.connection.close();
            }
          } else {
            this.onLeave.invoke(ServerError_1.CloseCode.CONSENTED);
          }
        });
      }
      onMessage(type, callback) {
        return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);
      }
      send(type, message) {
        const initialBytes = [Protocol_1.Protocol.ROOM_DATA];
        if (typeof type === "string") {
          schema_1.encode.string(initialBytes, type);
        } else {
          schema_1.encode.number(initialBytes, type);
        }
        let arr;
        if (message !== void 0) {
          const encoded = msgpack.encode(message);
          arr = new Uint8Array(initialBytes.length + encoded.byteLength);
          arr.set(new Uint8Array(initialBytes), 0);
          arr.set(new Uint8Array(encoded), initialBytes.length);
        } else {
          arr = new Uint8Array(initialBytes);
        }
        this.connection.send(arr.buffer);
      }
      sendBytes(type, bytes) {
        const initialBytes = [Protocol_1.Protocol.ROOM_DATA_BYTES];
        if (typeof type === "string") {
          schema_1.encode.string(initialBytes, type);
        } else {
          schema_1.encode.number(initialBytes, type);
        }
        let arr;
        arr = new Uint8Array(initialBytes.length + (bytes.byteLength || bytes.length));
        arr.set(new Uint8Array(initialBytes), 0);
        arr.set(new Uint8Array(bytes), initialBytes.length);
        this.connection.send(arr.buffer);
      }
      get state() {
        return this.serializer.getState();
      }
      removeAllListeners() {
        this.onJoin.clear();
        this.onStateChange.clear();
        this.onError.clear();
        this.onLeave.clear();
        this.onMessageHandlers.events = {};
      }
      onMessageCallback(event) {
        const bytes = Array.from(new Uint8Array(event.data));
        const code = bytes[0];
        if (code === Protocol_1.Protocol.JOIN_ROOM) {
          let offset = 1;
          const reconnectionToken = (0, Protocol_1.utf8Read)(bytes, offset);
          offset += (0, Protocol_1.utf8Length)(reconnectionToken);
          this.serializerId = (0, Protocol_1.utf8Read)(bytes, offset);
          offset += (0, Protocol_1.utf8Length)(this.serializerId);
          if (!this.serializer) {
            const serializer = (0, Serializer_1.getSerializer)(this.serializerId);
            this.serializer = new serializer();
          }
          if (bytes.length > offset && this.serializer.handshake) {
            this.serializer.handshake(bytes, { offset });
          }
          this.reconnectionToken = `${this.roomId}:${reconnectionToken}`;
          this.hasJoined = true;
          this.onJoin.invoke();
          this.connection.send([Protocol_1.Protocol.JOIN_ROOM]);
        } else if (code === Protocol_1.Protocol.ERROR) {
          const it = { offset: 1 };
          const code2 = schema_1.decode.number(bytes, it);
          const message = schema_1.decode.string(bytes, it);
          this.onError.invoke(code2, message);
        } else if (code === Protocol_1.Protocol.LEAVE_ROOM) {
          this.leave();
        } else if (code === Protocol_1.Protocol.ROOM_DATA_SCHEMA) {
          const it = { offset: 1 };
          const context = this.serializer.getState().constructor._context;
          const type = context.get(schema_1.decode.number(bytes, it));
          const message = new type();
          message.decode(bytes, it);
          this.dispatchMessage(type, message);
        } else if (code === Protocol_1.Protocol.ROOM_STATE) {
          bytes.shift();
          this.setState(bytes);
        } else if (code === Protocol_1.Protocol.ROOM_STATE_PATCH) {
          bytes.shift();
          this.patch(bytes);
        } else if (code === Protocol_1.Protocol.ROOM_DATA) {
          const it = { offset: 1 };
          const type = schema_1.decode.stringCheck(bytes, it) ? schema_1.decode.string(bytes, it) : schema_1.decode.number(bytes, it);
          const message = bytes.length > it.offset ? msgpack.decode(event.data, it.offset) : void 0;
          this.dispatchMessage(type, message);
        } else if (code === Protocol_1.Protocol.ROOM_DATA_BYTES) {
          const it = { offset: 1 };
          const type = schema_1.decode.stringCheck(bytes, it) ? schema_1.decode.string(bytes, it) : schema_1.decode.number(bytes, it);
          this.dispatchMessage(type, new Uint8Array(bytes.slice(it.offset)));
        }
      }
      setState(encodedState) {
        this.serializer.setState(encodedState);
        this.onStateChange.invoke(this.serializer.getState());
      }
      patch(binaryPatch) {
        this.serializer.patch(binaryPatch);
        this.onStateChange.invoke(this.serializer.getState());
      }
      dispatchMessage(type, message) {
        var _a;
        const messageType = this.getMessageHandlerKey(type);
        if (this.onMessageHandlers.events[messageType]) {
          this.onMessageHandlers.emit(messageType, message);
        } else if (this.onMessageHandlers.events["*"]) {
          this.onMessageHandlers.emit("*", type, message);
        } else {
          (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `colyseus.js: onMessage() not registered for type '${type}'.`);
        }
      }
      destroy() {
        if (this.serializer) {
          this.serializer.teardown();
        }
      }
      getMessageHandlerKey(type) {
        switch (typeof type) {
          // typeof Schema
          case "function":
            return `$${type._typeid}`;
          // string
          case "string":
            return type;
          // number
          case "number":
            return `i${type}`;
          default:
            throw new Error("invalid message type.");
        }
      }
    };
    exports.Room = Room;
  }
});

// ../node_modules/httpie/xhr/index.mjs
var xhr_exports = {};
__export(xhr_exports, {
  del: () => del,
  get: () => get,
  patch: () => patch,
  post: () => post,
  put: () => put,
  send: () => send
});
function apply(src, tar) {
  tar.headers = src.headers || {};
  tar.statusMessage = src.statusText;
  tar.statusCode = src.status;
  tar.data = src.response;
}
function send(method, uri, opts) {
  return new Promise(function(res, rej) {
    opts = opts || {};
    var req = new XMLHttpRequest();
    var k, tmp, arr, str = opts.body;
    var headers = opts.headers || {};
    if (opts.timeout) req.timeout = opts.timeout;
    req.ontimeout = req.onerror = function(err) {
      err.timeout = err.type == "timeout";
      rej(err);
    };
    req.open(method, uri.href || uri);
    req.onload = function() {
      arr = req.getAllResponseHeaders().trim().split(/[\r\n]+/);
      apply(req, req);
      while (tmp = arr.shift()) {
        tmp = tmp.split(": ");
        req.headers[tmp.shift().toLowerCase()] = tmp.join(": ");
      }
      tmp = req.headers["content-type"];
      if (tmp && !!~tmp.indexOf("application/json")) {
        try {
          req.data = JSON.parse(req.data, opts.reviver);
        } catch (err) {
          apply(req, err);
          return rej(err);
        }
      }
      (req.status >= 400 ? rej : res)(req);
    };
    if (typeof FormData < "u" && str instanceof FormData) {
    } else if (str && typeof str == "object") {
      headers["content-type"] = "application/json";
      str = JSON.stringify(str);
    }
    req.withCredentials = !!opts.withCredentials;
    for (k in headers) {
      req.setRequestHeader(k, headers[k]);
    }
    req.send(str);
  });
}
var get, post, patch, del, put;
var init_xhr = __esm({
  "../node_modules/httpie/xhr/index.mjs"() {
    get = send.bind(send, "GET");
    post = send.bind(send, "POST");
    patch = send.bind(send, "PATCH");
    del = send.bind(send, "DELETE");
    put = send.bind(send, "PUT");
  }
});

// ../node_modules/colyseus.js/lib/HTTP.js
var require_HTTP = __commonJS({
  "../node_modules/colyseus.js/lib/HTTP.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HTTP = void 0;
    var ServerError_1 = require_ServerError();
    var httpie = __importStar((init_xhr(), __toCommonJS(xhr_exports)));
    var HTTP = class {
      constructor(client, headers = {}) {
        this.client = client;
        this.headers = headers;
      }
      get(path, options = {}) {
        return this.request("get", path, options);
      }
      post(path, options = {}) {
        return this.request("post", path, options);
      }
      del(path, options = {}) {
        return this.request("del", path, options);
      }
      put(path, options = {}) {
        return this.request("put", path, options);
      }
      request(method, path, options = {}) {
        return httpie[method](this.client["getHttpEndpoint"](path), this.getOptions(options)).catch((e) => {
          var _a;
          const status = e.statusCode;
          const message = ((_a = e.data) === null || _a === void 0 ? void 0 : _a.error) || e.statusMessage || e.message;
          if (!status && !message) {
            throw e;
          }
          throw new ServerError_1.ServerError(status, message);
        });
      }
      getOptions(options) {
        options.headers = Object.assign({}, this.headers, options.headers);
        if (this.authToken) {
          options.headers["Authorization"] = `Bearer ${this.authToken}`;
        }
        if (typeof cc !== "undefined" && cc.sys && cc.sys.isNative) {
        } else {
          options.withCredentials = true;
        }
        return options;
      }
    };
    exports.HTTP = HTTP;
  }
});

// ../node_modules/colyseus.js/lib/Storage.js
var require_Storage = __commonJS({
  "../node_modules/colyseus.js/lib/Storage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getItem = exports.removeItem = exports.setItem = void 0;
    var storage;
    function getStorage() {
      if (!storage) {
        try {
          storage = typeof cc !== "undefined" && cc.sys && cc.sys.localStorage ? cc.sys.localStorage : window.localStorage;
        } catch (e) {
        }
      }
      if (!storage) {
        storage = {
          cache: {},
          setItem: function(key, value) {
            this.cache[key] = value;
          },
          getItem: function(key) {
            this.cache[key];
          },
          removeItem: function(key) {
            delete this.cache[key];
          }
        };
      }
      return storage;
    }
    function setItem(key, value) {
      getStorage().setItem(key, value);
    }
    exports.setItem = setItem;
    function removeItem(key) {
      getStorage().removeItem(key);
    }
    exports.removeItem = removeItem;
    function getItem(key, callback) {
      const value = getStorage().getItem(key);
      if (typeof Promise === "undefined" || // old browsers
      !(value instanceof Promise)) {
        callback(value);
      } else {
        value.then((id) => callback(id));
      }
    }
    exports.getItem = getItem;
  }
});

// ../node_modules/colyseus.js/lib/Auth.js
var require_Auth = __commonJS({
  "../node_modules/colyseus.js/lib/Auth.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _Auth__initialized;
    var _Auth__initializationPromise;
    var _Auth__signInWindow;
    var _Auth__events;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Auth = void 0;
    var Storage_1 = require_Storage();
    var nanoevents_1 = require_nanoevents();
    var Auth = class {
      constructor(http) {
        this.http = http;
        this.settings = {
          path: "/auth",
          key: "colyseus-auth-token"
        };
        _Auth__initialized.set(this, false);
        _Auth__initializationPromise.set(this, void 0);
        _Auth__signInWindow.set(this, void 0);
        _Auth__events.set(this, (0, nanoevents_1.createNanoEvents)());
        (0, Storage_1.getItem)(this.settings.key, (token) => this.token = token);
      }
      set token(token) {
        this.http.authToken = token;
      }
      get token() {
        return this.http.authToken;
      }
      onChange(callback) {
        const unbindChange = __classPrivateFieldGet(this, _Auth__events, "f").on("change", callback);
        if (!__classPrivateFieldGet(this, _Auth__initialized, "f")) {
          __classPrivateFieldSet(this, _Auth__initializationPromise, new Promise((resolve, reject) => {
            this.getUserData().then((userData) => {
              this.emitChange(Object.assign(Object.assign({}, userData), { token: this.token }));
            }).catch((e) => {
              this.emitChange({ user: null, token: void 0 });
            }).finally(() => {
              resolve();
            });
          }), "f");
        }
        __classPrivateFieldSet(this, _Auth__initialized, true, "f");
        return unbindChange;
      }
      getUserData() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.token) {
            return (yield this.http.get(`${this.settings.path}/userdata`)).data;
          } else {
            throw new Error("missing auth.token");
          }
        });
      }
      registerWithEmailAndPassword(email, password, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = (yield this.http.post(`${this.settings.path}/register`, {
            body: { email, password, options }
          })).data;
          this.emitChange(data);
          return data;
        });
      }
      signInWithEmailAndPassword(email, password) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = (yield this.http.post(`${this.settings.path}/login`, {
            body: { email, password }
          })).data;
          this.emitChange(data);
          return data;
        });
      }
      signInAnonymously(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = (yield this.http.post(`${this.settings.path}/anonymous`, {
            body: { options }
          })).data;
          this.emitChange(data);
          return data;
        });
      }
      sendPasswordResetEmail(email) {
        return __awaiter(this, void 0, void 0, function* () {
          return (yield this.http.post(`${this.settings.path}/forgot-password`, {
            body: { email }
          })).data;
        });
      }
      signInWithProvider(providerName, settings = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            const w = settings.width || 480;
            const h = settings.height || 768;
            const upgradingToken = this.token ? `?token=${this.token}` : "";
            const title = `Login with ${providerName[0].toUpperCase() + providerName.substring(1)}`;
            const url = this.http["client"]["getHttpEndpoint"](`${settings.prefix || `${this.settings.path}/provider`}/${providerName}${upgradingToken}`);
            const left = screen.width / 2 - w / 2;
            const top = screen.height / 2 - h / 2;
            __classPrivateFieldSet(this, _Auth__signInWindow, window.open(url, title, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + top + ", left=" + left), "f");
            const onMessage = (event) => {
              if (event.data.user === void 0 && event.data.token === void 0) {
                return;
              }
              clearInterval(rejectionChecker);
              __classPrivateFieldGet(this, _Auth__signInWindow, "f").close();
              __classPrivateFieldSet(this, _Auth__signInWindow, void 0, "f");
              window.removeEventListener("message", onMessage);
              if (event.data.error !== void 0) {
                reject(event.data.error);
              } else {
                resolve(event.data);
                this.emitChange(event.data);
              }
            };
            const rejectionChecker = setInterval(() => {
              if (!__classPrivateFieldGet(this, _Auth__signInWindow, "f") || __classPrivateFieldGet(this, _Auth__signInWindow, "f").closed) {
                __classPrivateFieldSet(this, _Auth__signInWindow, void 0, "f");
                reject("cancelled");
                window.removeEventListener("message", onMessage);
              }
            }, 200);
            window.addEventListener("message", onMessage);
          });
        });
      }
      signOut() {
        return __awaiter(this, void 0, void 0, function* () {
          this.emitChange({ user: null, token: null });
        });
      }
      emitChange(authData) {
        if (authData.token !== void 0) {
          this.token = authData.token;
          if (authData.token === null) {
            (0, Storage_1.removeItem)(this.settings.key);
          } else {
            (0, Storage_1.setItem)(this.settings.key, authData.token);
          }
        }
        __classPrivateFieldGet(this, _Auth__events, "f").emit("change", authData);
      }
    };
    exports.Auth = Auth;
    _Auth__initialized = /* @__PURE__ */ new WeakMap(), _Auth__initializationPromise = /* @__PURE__ */ new WeakMap(), _Auth__signInWindow = /* @__PURE__ */ new WeakMap(), _Auth__events = /* @__PURE__ */ new WeakMap();
  }
});

// ../node_modules/colyseus.js/lib/3rd_party/discord.js
var require_discord = __commonJS({
  "../node_modules/colyseus.js/lib/3rd_party/discord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discordURLBuilder = void 0;
    function discordURLBuilder(url) {
      var _a;
      const localHostname = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) || "localhost";
      const remoteHostnameSplitted = url.hostname.split(".");
      const subdomain = !url.hostname.includes("trycloudflare.com") && // ignore cloudflared subdomains
      !url.hostname.includes("discordsays.com") && // ignore discordsays.com subdomains
      remoteHostnameSplitted.length > 2 ? `/${remoteHostnameSplitted[0]}` : "";
      return url.pathname.startsWith("/.proxy") ? `${url.protocol}//${localHostname}${subdomain}${url.pathname}${url.search}` : `${url.protocol}//${localHostname}/.proxy/colyseus${subdomain}${url.pathname}${url.search}`;
    }
    exports.discordURLBuilder = discordURLBuilder;
  }
});

// ../node_modules/colyseus.js/lib/Client.js
var require_Client = __commonJS({
  "../node_modules/colyseus.js/lib/Client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = exports.MatchMakeError = void 0;
    var ServerError_1 = require_ServerError();
    var Room_1 = require_Room();
    var HTTP_1 = require_HTTP();
    var Auth_1 = require_Auth();
    var discord_1 = require_discord();
    var MatchMakeError = class _MatchMakeError extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _MatchMakeError.prototype);
      }
    };
    exports.MatchMakeError = MatchMakeError;
    var DEFAULT_ENDPOINT = typeof window !== "undefined" && typeof ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) !== "undefined" ? `${window.location.protocol.replace("http", "ws")}//${window.location.hostname}${window.location.port && `:${window.location.port}`}` : "ws://127.0.0.1:2567";
    var Client = class {
      constructor(settings = DEFAULT_ENDPOINT, options) {
        var _a2, _b;
        if (typeof settings === "string") {
          const url = settings.startsWith("/") ? new URL(settings, DEFAULT_ENDPOINT) : new URL(settings);
          const secure = url.protocol === "https:" || url.protocol === "wss:";
          const port = Number(url.port || (secure ? 443 : 80));
          this.settings = {
            hostname: url.hostname,
            pathname: url.pathname,
            port,
            secure
          };
        } else {
          if (settings.port === void 0) {
            settings.port = settings.secure ? 443 : 80;
          }
          if (settings.pathname === void 0) {
            settings.pathname = "";
          }
          this.settings = settings;
        }
        if (this.settings.pathname.endsWith("/")) {
          this.settings.pathname = this.settings.pathname.slice(0, -1);
        }
        this.http = new HTTP_1.HTTP(this, (options === null || options === void 0 ? void 0 : options.headers) || {});
        this.auth = new Auth_1.Auth(this.http);
        this.urlBuilder = options === null || options === void 0 ? void 0 : options.urlBuilder;
        if (!this.urlBuilder && typeof window !== "undefined" && ((_b = (_a2 = window === null || window === void 0 ? void 0 : window.location) === null || _a2 === void 0 ? void 0 : _a2.hostname) === null || _b === void 0 ? void 0 : _b.includes("discordsays.com"))) {
          this.urlBuilder = discord_1.discordURLBuilder;
          console.log("Colyseus SDK: Discord Embedded SDK detected. Using custom URL builder.");
        }
      }
      joinOrCreate(roomName, options = {}, rootSchema) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.createMatchMakeRequest("joinOrCreate", roomName, options, rootSchema);
        });
      }
      create(roomName, options = {}, rootSchema) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.createMatchMakeRequest("create", roomName, options, rootSchema);
        });
      }
      join(roomName, options = {}, rootSchema) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.createMatchMakeRequest("join", roomName, options, rootSchema);
        });
      }
      joinById(roomId, options = {}, rootSchema) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.createMatchMakeRequest("joinById", roomId, options, rootSchema);
        });
      }
      /**
       * Re-establish connection with a room this client was previously connected to.
       *
       * @param reconnectionToken The `room.reconnectionToken` from previously connected room.
       * @param rootSchema (optional) Concrete root schema definition
       * @returns Promise<Room>
       */
      reconnect(reconnectionToken, rootSchema) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof reconnectionToken === "string" && typeof rootSchema === "string") {
            throw new Error("DEPRECATED: .reconnect() now only accepts 'reconnectionToken' as argument.\nYou can get this token from previously connected `room.reconnectionToken`");
          }
          const [roomId, token] = reconnectionToken.split(":");
          if (!roomId || !token) {
            throw new Error("Invalid reconnection token format.\nThe format should be roomId:reconnectionToken");
          }
          return yield this.createMatchMakeRequest("reconnect", roomId, { reconnectionToken: token }, rootSchema);
        });
      }
      getAvailableRooms(roomName = "") {
        return __awaiter(this, void 0, void 0, function* () {
          return (yield this.http.get(`matchmake/${roomName}`, {
            headers: {
              "Accept": "application/json"
            }
          })).data;
        });
      }
      consumeSeatReservation(response, rootSchema, reuseRoomInstance) {
        return __awaiter(this, void 0, void 0, function* () {
          const room = this.createRoom(response.room.name, rootSchema);
          room.roomId = response.room.roomId;
          room.sessionId = response.sessionId;
          const options = { sessionId: room.sessionId };
          if (response.reconnectionToken) {
            options.reconnectionToken = response.reconnectionToken;
          }
          const targetRoom = reuseRoomInstance || room;
          room.connect(this.buildEndpoint(response.room, options), response.devMode && (() => __awaiter(this, void 0, void 0, function* () {
            console.info(`[Colyseus devMode]: ${String.fromCodePoint(128260)} Re-establishing connection with room id '${room.roomId}'...`);
            let retryCount = 0;
            let retryMaxRetries = 8;
            const retryReconnection = () => __awaiter(this, void 0, void 0, function* () {
              retryCount++;
              try {
                yield this.consumeSeatReservation(response, rootSchema, targetRoom);
                console.info(`[Colyseus devMode]: ${String.fromCodePoint(9989)} Successfully re-established connection with room '${room.roomId}'`);
              } catch (e) {
                if (retryCount < retryMaxRetries) {
                  console.info(`[Colyseus devMode]: ${String.fromCodePoint(128260)} retrying... (${retryCount} out of ${retryMaxRetries})`);
                  setTimeout(retryReconnection, 2e3);
                } else {
                  console.info(`[Colyseus devMode]: ${String.fromCodePoint(10060)} Failed to reconnect. Is your server running? Please check server logs.`);
                }
              }
            });
            setTimeout(retryReconnection, 2e3);
          })), targetRoom, this.http.headers);
          return new Promise((resolve, reject) => {
            const onError = (code, message) => reject(new ServerError_1.ServerError(code, message));
            targetRoom.onError.once(onError);
            targetRoom["onJoin"].once(() => {
              targetRoom.onError.remove(onError);
              resolve(targetRoom);
            });
          });
        });
      }
      createMatchMakeRequest(method, roomName, options = {}, rootSchema, reuseRoomInstance) {
        return __awaiter(this, void 0, void 0, function* () {
          const response = (yield this.http.post(`matchmake/${method}/${roomName}`, {
            headers: {
              "Accept": "application/json",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(options)
          })).data;
          if (response.error) {
            throw new MatchMakeError(response.error, response.code);
          }
          if (method === "reconnect") {
            response.reconnectionToken = options.reconnectionToken;
          }
          return yield this.consumeSeatReservation(response, rootSchema, reuseRoomInstance);
        });
      }
      createRoom(roomName, rootSchema) {
        return new Room_1.Room(roomName, rootSchema);
      }
      buildEndpoint(room, options = {}) {
        const params = [];
        for (const name in options) {
          if (!options.hasOwnProperty(name)) {
            continue;
          }
          params.push(`${name}=${options[name]}`);
        }
        let endpoint = this.settings.secure ? "wss://" : "ws://";
        if (room.publicAddress) {
          endpoint += `${room.publicAddress}`;
        } else {
          endpoint += `${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}`;
        }
        const endpointURL = `${endpoint}/${room.processId}/${room.roomId}?${params.join("&")}`;
        return this.urlBuilder ? this.urlBuilder(new URL(endpointURL)) : endpointURL;
      }
      getHttpEndpoint(segments = "") {
        const path = segments.startsWith("/") ? segments : `/${segments}`;
        const endpointURL = `${this.settings.secure ? "https" : "http"}://${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}${path}`;
        return this.urlBuilder ? this.urlBuilder(new URL(endpointURL)) : endpointURL;
      }
      getEndpointPort() {
        return this.settings.port !== 80 && this.settings.port !== 443 ? `:${this.settings.port}` : "";
      }
    };
    exports.Client = Client;
  }
});

// ../node_modules/colyseus.js/lib/serializer/SchemaSerializer.js
var require_SchemaSerializer = __commonJS({
  "../node_modules/colyseus.js/lib/serializer/SchemaSerializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaSerializer = void 0;
    var schema_1 = require_umd();
    var SchemaSerializer = class {
      setState(rawState) {
        return this.state.decode(rawState);
      }
      getState() {
        return this.state;
      }
      patch(patches) {
        return this.state.decode(patches);
      }
      teardown() {
        var _a, _b;
        (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a["$changes"]) === null || _b === void 0 ? void 0 : _b.root.clearRefs();
      }
      handshake(bytes, it) {
        if (this.state) {
          const reflection = new schema_1.Reflection();
          reflection.decode(bytes, it);
        } else {
          this.state = schema_1.Reflection.decode(bytes, it);
        }
      }
    };
    exports.SchemaSerializer = SchemaSerializer;
  }
});

// ../node_modules/colyseus.js/lib/serializer/NoneSerializer.js
var require_NoneSerializer = __commonJS({
  "../node_modules/colyseus.js/lib/serializer/NoneSerializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoneSerializer = void 0;
    var NoneSerializer = class {
      setState(rawState) {
      }
      getState() {
        return null;
      }
      patch(patches) {
      }
      teardown() {
      }
      handshake(bytes) {
      }
    };
    exports.NoneSerializer = NoneSerializer;
  }
});

// ../node_modules/colyseus.js/lib/index.js
var require_lib = __commonJS({
  "../node_modules/colyseus.js/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaSerializer = exports.registerSerializer = exports.Auth = exports.Room = exports.ErrorCode = exports.Protocol = exports.MatchMakeError = exports.Client = void 0;
    require_legacy();
    var Client_1 = require_Client();
    Object.defineProperty(exports, "Client", { enumerable: true, get: function() {
      return Client_1.Client;
    } });
    Object.defineProperty(exports, "MatchMakeError", { enumerable: true, get: function() {
      return Client_1.MatchMakeError;
    } });
    var Protocol_1 = require_Protocol();
    Object.defineProperty(exports, "Protocol", { enumerable: true, get: function() {
      return Protocol_1.Protocol;
    } });
    Object.defineProperty(exports, "ErrorCode", { enumerable: true, get: function() {
      return Protocol_1.ErrorCode;
    } });
    var Room_1 = require_Room();
    Object.defineProperty(exports, "Room", { enumerable: true, get: function() {
      return Room_1.Room;
    } });
    var Auth_1 = require_Auth();
    Object.defineProperty(exports, "Auth", { enumerable: true, get: function() {
      return Auth_1.Auth;
    } });
    var SchemaSerializer_1 = require_SchemaSerializer();
    Object.defineProperty(exports, "SchemaSerializer", { enumerable: true, get: function() {
      return SchemaSerializer_1.SchemaSerializer;
    } });
    var NoneSerializer_1 = require_NoneSerializer();
    var Serializer_1 = require_Serializer();
    Object.defineProperty(exports, "registerSerializer", { enumerable: true, get: function() {
      return Serializer_1.registerSerializer;
    } });
    (0, Serializer_1.registerSerializer)("schema", SchemaSerializer_1.SchemaSerializer);
    (0, Serializer_1.registerSerializer)("none", NoneSerializer_1.NoneSerializer);
  }
});
export default require_lib();
//# sourceMappingURL=colyseus__js.js.map
